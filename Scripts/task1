import numpy as np
import datetime
from timeit import default_timer as timer
import time
from numpy import linalg as LA
import matplotlib.pyplot as plt
import seaborn as sns

const = np.random.randint(0, 1, 1)
right_bound = 10


def f_const(v):
    start_time = time.time()
    const = np.random.randint(0, 1, 1)
    end_time = time.time() - start_time
    return end_time, const


def f_sum(v):
    start_time = timer()
    sum = 0
    for i in range(len(v)):
        sum = sum + v[i]
    end_time = timer() - start_time
    return end_time


def f_product(v):
    start_time = time.time()
    product = np.product(v)
    end_time = time.time() - start_time
    return end_time


def f_norm(v):
    start_time = time.time()
    norm = LA.norm(v)
    end_time = time.time() - start_time
    return end_time


def f_polynomial_direct(v, x):
    start_time = time.time()
    p_x = np.sum([v[k] * x ** (k - 1) for k in range(1, len(v + 1))])
    end_time = time.time() - start_time
    return end_time


def f_polynomial_horner(v, x):
    start_time = time.time()
    p_x = v[0]
    for i in range(1, len(v)):
        p_x = p_x * x + v[i]
    end_time = time.time() - start_time
    return end_time


def f_bubblesort(v):
    start_time = time.time()
    for i in range(len(v) - 2):
        for j in range(len(v) - 2):
            if v[j] > v[j + 1]:
                v[j], v[j + 1] = v[j + 1], v[j]
    end_time = time.time() - start_time
    return end_time


def matrix_product(n):
    start_time = time.time()
    A = np.random.randint(right_bound, size=(n, n))
    B = np.random.randint(right_bound, size=(n, n))
    A_dot_B = np.matmul(A, B)
    end_time = time.time() - start_time
    return end_time


def plot_graph(emperical, n_list):
    ax = sns.regplot(x=n_list, y=emperical)
    ax1 = sns.relplot(x=n_list, y=n_list)
    plt.show()
    plt.plot(n_list, emperical)
    plt.xlabel('n - axis')
    plt.ylabel('time - axis')
    plt.show() 


def main():
    time_const = []
    time_sum = []
    time_product = []
    time_norm = []
    time_polynomial_direct = []
    time_polynomial_horner = []
    time_bubblesort = []
    time_matrix_product = []
    n_list = [i for i in range(0, 100, 50)]
    n_list[0] = 1
    for n in n_list:
        vector = np.random.uniform(1, 10, n)
        time_const_temp = []
        time_sum_temp = []
        time_product_temp = []
        time_norm_temp = []
        time_polynomial_direct_temp = []
        time_polynomial_horner_temp = []
        time_bubblesort_temp = []
        time_matrix_product_temp = []
        for k in range(5):
            time_const_temp.append(f_const(vector))
            time_sum_temp.append(f_sum(vector))
            time_product_temp.append(f_product(vector))
            time_norm_temp.append(f_norm(vector))
            time_polynomial_direct_temp.append(f_polynomial_direct(vector, 1.5))
            time_polynomial_horner_temp.append(f_polynomial_horner(vector, 1.5))
            time_bubblesort_temp.append(f_bubblesort(vector))
            time_matrix_product_temp.append(matrix_product(n))
        time_const.append(np.average(time_const_temp))
        time_sum.append(np.average(time_sum_temp))
        time_product.append(np.average(time_product_temp))
        time_norm.append(np.average(time_norm_temp))
        time_polynomial_direct.append(np.average(time_polynomial_direct_temp))
        time_polynomial_horner.append(np.average(time_polynomial_horner_temp))
        time_bubblesort.append(np.average(time_bubblesort_temp))
        time_matrix_product.append(np.average(time_matrix_product_temp))
    # plot_graph(time_const, n_list)
    plot_graph(time_sum, n_list)
    # plot_graph(time_product, n_list)
    # plot_graph(time_norm_temp, n_list)
    # plot_graph(time_polynomial_direct, n_list)
    # plot_graph(time_polynomial_horner, n_list)
    # plot_graph(time_bubblesort, n_list)
    # plot_graph(time_matrix_product, n_list)


if __name__ == '__main__':
    main()
